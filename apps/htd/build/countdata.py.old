
import os
import csv
import math
from scipy.stats import chisquare as scipy_chisquare
import numpy as np

normalized_total = 10000


def countdata_iterator(**kwargs):
    dir = kwargs.get('dir')
    tm = kwargs.get('tree_manager')

    files = [f for f in os.listdir(dir) if f.endswith('.csv')]
    for filepath in files:
        element_id = os.path.splitext(filepath)[0]
        cd = CountData(id=element_id,
                       tree_manager=tm,
                       file=os.path.join(dir, filepath))
        yield cd


class CountData(object):

    def __init__(self, **kwargs):
        self.id = int(kwargs.get('id'))
        self.tm = kwargs.get('tree_manager')
        self._load_data(kwargs.get('file'))

    def _load_data(self, fname):
        self.countsets = {}
        with open(fname, 'rb') as csvfile:
            csvreader = csv.reader(csvfile)
            for row in csvreader:
                j = CountSet(thesaurus_id=row[0],
                             alpha=row[1],
                             beta=row[2],
                             compound=row[3])
                self.countsets[j.thesaurus_id] = j

        # Add zero values for any classes missed out
        for c in self.tm.classes:
            if not c.id() in self.countsets:
                self.countsets[c.id()] = CountSet(thesaurus_id=c.id(),
                                                  alpha=0,
                                                  beta=0,
                                                  compounds=0)
            self.countsets[c.id()].thesaurus_class = c

        # Add branch_total (sum of this node + all descendants' totals)
        for cs in self.countsets.values():
            cs.branch_total = 0
        for c in self.tm.classes:
            for p in c.path():
                self.countsets[p].branch_total += self.countsets[c.id()].total()

        # Add level, share, density, and normalized_density attributes
        normalizing_ratio = normalized_total / self.total()
        for c in self.tm.classes:
            j = self.countsets[c.id()]
            j.level = c.level()
            j.density = j.branch_total / c.size(branch=True)
            j.normalized_density = j.density * normalizing_ratio
            j.share = j.branch_total / self.total()

    def total(self):
        try:
            return self.tot
        except AttributeError:
            self.tot = sum([c.total() for c in self.countsets.values()])
            return self.tot

    def classes_by_density(self, **kwargs):
        level = kwargs.get('level', 3)
        return sorted([j for j in self.countsets.values() if j.level == level],
                       key=lambda j: j.density, reverse=True)

    def classes_by_share(self, **kwargs):
        level = kwargs.get('level', 3)
        return sorted([j for j in self.countsets.values() if j.level == level],
                       key=lambda j: j.share, reverse=True)

    def chisquare(self, **kwargs):
        level = kwargs.get('level', 3)
        min = 5

        classes = [c for c in self.tm.classes if c.level() == level]
        taxonomy_total = sum([c.size(branch=True) for c in classes])
        observed = [self.countsets[c.id()].branch_total for c in classes]
        total = sum(observed)

        expected = []
        for c in classes:
            e = (float(c.size(branch=True)) / float(taxonomy_total)) * total
            expected.append(e)

        observed2 = []
        expected2 = []
        for o, e in [(o, e) for (o, e) in zip(observed, expected) if e >= 5]:
            observed2.append(o)
            expected2.append(e)
        if not observed2:
            for o, e in [(o, e) for (o, e) in zip(observed, expected) if e >= 1]:
                observed2.append(o)
                expected2.append(e)

        observed = np.array(observed2)
        expected = np.array(expected2)
        return scipy_chisquare(observed, expected)


        #for c in [c for c in self.tm.classes if c.level() == level]:
        #    j = self.countsets[c.id()]
        #    expected = self.total() * (
        #               float(c.size(branch=True)) / float(taxonomy_total))
        #    observed = j.branch_total
        #    sk += abs(observed - expected)
        #return sk / self.total()

    def share_distance(self, other, **kwargs):
        mode = kwargs.get('mode', 'share')
        diff = 0
        for dp in self.distribution:
            thes_id = dp.thesaurus_class.id()
            v1 = dp._asdict()[mode]
            v2 = other.distribution_idx[thes_id]._asdict()[mode]
            if mode == 'share':
                diff += abs(v1 - v2)
            elif mode == 'normalized_density':
                diff += abs(v1 - v2) * math.log(c.size(branch=True))
        return diff


class CountSet(object):

    def __init__(self, **kwargs):
        for t in ('thesaurus_id', 'alpha', 'beta', 'compound'):
            self.__dict__[t] = int(kwargs.get(t, 0))

    def total(self):
        return sum([self.alpha, self.beta, self.compound])
